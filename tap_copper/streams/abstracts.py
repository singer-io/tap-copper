from abc import ABC, abstractmethod
from typing import Any, Dict, Tuple, List, Iterator
from singer import (
    Transformer,
    get_bookmark,
    get_logger,
    metrics,
    write_bookmark,
    write_record,
    write_schema,
    metadata
)

LOGGER = get_logger()


class BaseStream(ABC):
    """
    Base class for streams generated by the tap generator.

    Minimal fixes:
    - In get_records(), pass JSON body as a dict (not dumps) to avoid `_json` errors server-side.
    - get_url_endpoint() strips leading slash from path to avoid double '//' in URLs.
    - update_data_payload keeps **kwargs so per-stream overrides can inject body fields.
    """

    url_endpoint = ""
    path = ""
    page_size = 0
    next_page_key = ""
    headers = {
        'X-PW-AccessToken': '{{ api_key }}',
        'X-PW-Application': 'developer_api',
        'X-PW-UserEmail': '{{ user_email }}',
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    children: List["BaseStream"] = []
    parent = ""
    data_key = ""
    parent_bookmark_key = ""
    http_method = "POST"

    def __init__(self, client=None, catalog=None) -> None:
        self.client = client
        self.catalog = catalog
        self.schema = catalog.schema.to_dict()
        self.metadata = metadata.to_map(catalog.metadata)
        self.child_to_sync: List["BaseStream"] = []
        self.params: Dict[str, Any] = {}
        self.data_payload: Dict[str, Any] = {}

    @property
    @abstractmethod
    def tap_stream_id(self) -> str:
        """Unique identifier for the stream."""

    @property
    @abstractmethod
    def replication_method(self) -> str:
        """Defines the sync mode of a stream."""

    @property
    @abstractmethod
    def replication_keys(self) -> List:
        """Defines the replication key(s) for incremental sync."""

    @property
    @abstractmethod
    def key_properties(self) -> Tuple[str, str]:
        """List of key properties for stream."""

    def is_selected(self):
        return metadata.get(self.metadata, (), "selected")

    @abstractmethod
    def sync(
        self,
        state: Dict,
        transformer: Transformer,
        parent_obj: Dict = None,
    ) -> Dict:
        """Perform the replication sync."""

    def get_records(self) -> Iterator:
        """Generic API interaction + pagination loop."""
        # Keep generator behavior; harmless even if unused.
        self.params[""] = self.page_size
        next_page = 1
        while next_page:
            response = self.client.make_request(
                self.http_method,
                self.url_endpoint,
                self.params,
                self.headers,
                body=self.data_payload,   # send dict; client uses requests(..., json=body)
                path=self.path
            )
            raw_records = response.get(self.data_key, []) if isinstance(response, dict) else []
            next_page = response.get(self.next_page_key) if isinstance(response, dict) else None
            if self.next_page_key:
                self.params[self.next_page_key] = next_page
            yield from raw_records

    def write_schema(self) -> None:
        try:
            write_schema(self.tap_stream_id, self.schema, self.key_properties)
        except OSError as err:
            LOGGER.error("OS Error while writing schema for: %s", self.tap_stream_id)
            raise err

    def update_params(self, **kwargs) -> None:
        """Update query params for the stream."""
        self.params.update(kwargs)

    def update_data_payload(self, **kwargs) -> None:
        """Update JSON body for the stream."""
        self.data_payload.update(kwargs)

    def modify_object(self, record: Dict, parent_record: Dict = None) -> Dict:
        """Hook to modify a record before writing."""
        return record

    def get_url_endpoint(self, parent_obj: Dict = None) -> str:
        """Build URL endpoint with safe slash handling."""
        return self.url_endpoint or f"{self.client.base_url}/{str(self.path).lstrip('/')}"

class IncrementalStream(BaseStream):
    """Base Class for Incremental Stream."""

    def get_bookmark(self, state: dict, stream: str, key: Any = None) -> int:
        """Wrap singer.get_bookmark; default start_date is required in config."""
        return get_bookmark(
            state,
            stream,
            key or self.replication_keys[0],
            self.client.config["start_date"],  # numeric epoch (seconds) per your schema
        )

    def write_bookmark(self, state: dict, stream: str, key: Any = None, value: Any = None) -> Dict:
        if not (key or self.replication_keys):
            return state
        current_bookmark = get_bookmark(
            state, stream, key or self.replication_keys[0], self.client.config["start_date"]
        )
        value = max(current_bookmark, value)
        return write_bookmark(state, stream, key or self.replication_keys[0], value)

    def sync(
        self,
        state: Dict,
        transformer: Transformer,
        parent_obj: Dict = None,
    ) -> Dict:
        """Default incremental implementation."""
        bookmark_date = self.get_bookmark(state, self.tap_stream_id)
        current_max_bookmark_date = bookmark_date
        self.update_params(updated_since=bookmark_date)  # some streams override usage
        self.update_data_payload(**(parent_obj or {}))
        self.url_endpoint = self.get_url_endpoint(parent_obj)

        with metrics.record_counter(self.tap_stream_id) as counter:
            for record in self.get_records():
                record = self.modify_object(record, parent_obj)
                transformed_record = transformer.transform(
                    record, self.schema, self.metadata
                )

                record_bookmark = transformed_record[self.replication_keys[0]]
                if record_bookmark >= bookmark_date:
                    if self.is_selected():
                        write_record(self.tap_stream_id, transformed_record)
                        counter.increment()
                    if record_bookmark > current_max_bookmark_date:
                        current_max_bookmark_date = record_bookmark

                    for child in self.child_to_sync:
                        child.sync(state=state, transformer=transformer, parent_obj=record)

            state = self.write_bookmark(state, self.tap_stream_id, value=current_max_bookmark_date)
            return counter.value


class FullTableStream(BaseStream):
    """Base Class for Full Table Stream."""

    replication_keys = []

    def sync(
        self,
        state: Dict,
        transformer: Transformer,
        parent_obj: Dict = None,
    ) -> Dict:
        """Default full-table implementation."""
        self.url_endpoint = self.get_url_endpoint(parent_obj)
        self.update_data_payload(**(parent_obj or {}))
        with metrics.record_counter(self.tap_stream_id) as counter:
            for record in self.get_records():
                transformed_record = transformer.transform(
                    record, self.schema, self.metadata
                )
                if self.is_selected():
                    write_record(self.tap_stream_id, transformed_record)
                    counter.increment()

                for child in self.child_to_sync:
                    child.sync(state=state, transformer=transformer, parent_obj=record)

            return counter.value


class ParentBaseStream(IncrementalStream):
    """Base Class for Parent Stream."""

    def get_bookmark(self, state: Dict, stream: str, key: Any = None) -> int:
        min_parent_bookmark = super().get_bookmark(state, stream) if self.is_selected() else None
        for child in self.child_to_sync:
            bookmark_key = f"{self.tap_stream_id}_{self.replication_keys[0]}"
            child_bookmark = super().get_bookmark(state, child.tap_stream_id, key=bookmark_key)
            min_parent_bookmark = (
                min(min_parent_bookmark, child_bookmark)
                if min_parent_bookmark is not None
                else child_bookmark
            )
        return min_parent_bookmark

    def write_bookmark(
        self, state: Dict, stream: str, key: Any = None, value: Any = None
    ) -> Dict:
        if self.is_selected():
            super().write_bookmark(state, stream, value=value)
        for child in self.child_to_sync:
            bookmark_key = f"{self.tap_stream_id}_{self.replication_keys[0]}"
            super().write_bookmark(state, child.tap_stream_id, key=bookmark_key, value=value)
        return state


class ChildBaseStream(IncrementalStream):
    """Base Class for Child Stream."""

    def get_url_endpoint(self, parent_obj=None):
        """Prepare URL endpoint for child streams."""
        return f"{self.client.base_url}/{self.path.format(parent_obj['id'])}"

    def get_bookmark(self, state: Dict, stream: str, key: Any = None) -> int:
        """Singleton bookmark value for child streams."""
        if not hasattr(self, "bookmark_value"):
            self.bookmark_value = None
        if not self.bookmark_value:
            self.bookmark_value = super().get_bookmark(state, stream)
        return self.bookmark_value
